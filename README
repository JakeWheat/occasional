A demo system for running concurrent and distributed processes in
Python. Not yet usable.

Roadmap
-------

Implement process exit values

Mailbox system + selective receive

Spawn with shared listening port demo

Local system with spawn, send, receive, monitor

Distributed

Do and document examples below

Install
-------

install Python 3.10 or later
  -> before 3.10 is released you need the beta version
dependencies:
pip3 install python-prctl
pip3 install dill

Run the tests:

./test_framework.py


Examples (TODO)
---------------

running lots of tasks in parallel, three versions:
simplest possible in python
simplest possible which wraps an exe
'enterprise grade' with logging, monitoring
dynamic work queue version?

  two basic ways to use this system:
  feed stuff into a process, get out a list of commands to run
  feed stuff into a process, get out a list of arrays to run with a function
    or a list of functions to be called

running "server" exes, native and non native
  restarting when exit
  logging exit reasons
  providing monitoring and stuff

Theory
------

A concurrency/distributed framework demo based on some ideas from
Erlang, built in Python, uses Linux processes (and not Posix threads
or a green threads system).

The most critical aspect of the design is the reliable detection of
spawned process exit with the reason why.

* you spawn a new process using a Python function to run as the new
  process with minimal boilerplate
* you get an mailbox with that process that can receive messages
* the system uses simple message passing with native values, you pass
  mailboxes around as values which can then be sent to
* processes in this system are Linux processes
* you can reliably detect when and why a process exits on the local
  machine, whatever the reason
* you can as reliably as possible detect the same for remote processes
* there's a ports system like Erlang to run non native processes
* it's designed to build crash only systems, sigkill is routinely used
  on user processes

It is a usable system in its own right, it's also designed to be a
demo of one way to use Linux processes and sockets to create a system
like this, that could be ported to other programming languages.

It doesn't try to emulate the very fast process spawning and very fast
message passing of Erlang.
